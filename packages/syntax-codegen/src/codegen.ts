import crypto from 'node:crypto';

import { traverse, type NodePath } from '@babel/core';
import { generate } from '@babel/generator';
import { parse } from '@babel/parser';
import * as t from '@babel/types';
import {
  ResultType,
  SyntaxNodeType,
  isNodeTypeIdentifier,
  isNonNull,
  parseSyntaxAst,
  unreachable,
  type SyntaxChoiceNode,
  type SyntaxEmptyNode,
  type SyntaxExpressionNode,
  type SyntaxListNode,
  type SyntaxNonTerminalIdentifierNode,
  type SyntaxNonTerminalRuleNode,
  type SyntaxProgramNode,
  type SyntaxReadNode,
  type SyntaxSequenceNode,
  type SyntaxStructNode,
  type SyntaxTerminalIdentifierNode,
  type SyntaxTerminalRuleNode,
} from '@timkendrick/syntax';

// Static type name constants
const AST_NODE_TYPE = 'AstNode';
const SYNTAX_PARSER_TYPE = 'SyntaxParser';
const TOKEN_TYPE = 'Token';

export interface ImportOptions {
  moduleName: string;
  factory: string;
}

export function codegen(source: string, importOptions: ImportOptions): string | null {
  const { moduleName } = importOptions;
  // Locate all syntax definitions in the input source code
  const syntaxSources = findSyntaxSources(source, importOptions);
  if (syntaxSources.size === 0) return null;
  // Generate function declarations and corresponding type definitions for each syntax source
  const moduleStatements: Array<t.Statement> = Array.from(
    syntaxSources.entries().flatMap(([source, ast]) => {
      const { functionDeclaration, typeDefinitions } = generateSyntaxTypeDefinitions(
        source,
        ast,
        generateTypeNamePrefix(source),
        importOptions,
      );
      return [functionDeclaration, ...typeDefinitions];
    }),
  );
  // Combine all function declarations into a single module augmentation
  const program = t.program([
    // Import the required type dependencies from the syntax package
    Object.assign(
      t.importDeclaration(
        [
          t.importSpecifier(t.identifier(AST_NODE_TYPE), t.identifier(AST_NODE_TYPE)),
          t.importSpecifier(t.identifier(SYNTAX_PARSER_TYPE), t.identifier(SYNTAX_PARSER_TYPE)),
          t.importSpecifier(t.identifier(TOKEN_TYPE), t.identifier(TOKEN_TYPE)),
        ],
        t.stringLiteral(moduleName),
      ),
      {
        importKind: 'type',
      },
    ),
    // Declare the module augmentation
    Object.assign(
      t.tsModuleDeclaration(t.stringLiteral(moduleName), t.tsModuleBlock(moduleStatements)),
      {
        declare: true,
      },
    ),
  ]);
  return generateCode(program, {
    header: `// This file was generated by syntax-codegen. Do not edit!
/* eslint-disable */
`,
  });
}

function generateTypeNamePrefix(source: string): string {
  return `CustomSyntax_${hashSyntaxSource(source)}_`;
}

function hashSyntaxSource(source: string): string {
  return crypto.createHash('sha256').update(source).digest('hex').substring(0, 8);
}

function generateCode(program: t.Program, options?: { header?: string }): string {
  const { header = null } = options ?? {};
  const result = generate(program, {
    retainLines: false,
    compact: false,
  });
  const { code: output } = result;
  if (!header) return output;
  return `${header}${output}`;
}

function findSyntaxSources(
  source: string,
  importOptions: ImportOptions,
): Map<string, SyntaxProgramNode> {
  const languageDefinitions = findLanguageDefinitions(source, importOptions);
  return new Map(
    languageDefinitions.map((syntax) => {
      const parseResult = parseSyntaxAst(syntax);
      if (parseResult.type === ResultType.Error) throw parseResult.error;
      const ast = parseResult.value;
      return [syntax, ast];
    }),
  );
}

function findLanguageDefinitions(source: string, importOptions: ImportOptions): Array<string> {
  const results: Array<string> = [];
  // Parse the TypeScript/JavaScript source code (this will throw if the source is invalid)
  const ast = parse(source, {
    sourceType: 'module',
    plugins: ['typescript', 'jsx'],
  });
  // Traverse the AST to find calls to the syntax factory function
  traverse(ast, {
    CallExpression(path) {
      const { node } = path;
      if (node.arguments.length !== 1) return;
      const [arg] = node.arguments;
      const callee = path.get('callee');
      if (!callee.isIdentifier()) return;
      if (!isNamedModuleExportIdentifier(callee, importOptions.moduleName, importOptions.factory)) {
        return;
      }
      const stringArg = parseStringLiteral(arg);
      if (stringArg === null) return;
      results.push(stringArg);
    },
  });
  return results;
}

function generateSyntaxTypeDefinitions(
  source: string,
  ast: SyntaxProgramNode,
  typeNamePrefix: string,
  importOptions: ImportOptions,
): {
  functionDeclaration: t.ExportNamedDeclaration;
  typeDefinitions: Array<t.Statement>;
} {
  const { factory } = importOptions;
  const { tokenType, nodeType, rootNodeType, typeDefinitions } = generateSyntaxTypes(
    ast,
    typeNamePrefix,
  );

  // Create the function declaration
  const functionDeclaration = t.exportNamedDeclaration(
    t.tsDeclareFunction(
      t.identifier(factory),
      null,
      [
        Object.assign(t.identifier('source'), {
          typeAnnotation: t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(source))),
        }),
      ],
      t.tsTypeAnnotation(
        t.tsTypeReference(
          t.identifier(SYNTAX_PARSER_TYPE),
          t.tsTypeParameterInstantiation([
            t.tsTypeReference(tokenType),
            t.tsTypeReference(nodeType),
            t.tsTypeReference(rootNodeType),
          ]),
        ),
      ),
    ),
  );
  return { functionDeclaration, typeDefinitions };
}

export function generateSyntaxTypes(
  ast: SyntaxProgramNode,
  typeNamePrefix: string,
): {
  tokenType: t.Identifier;
  nodeType: t.Identifier;
  rootNodeType: t.Identifier;
  typeDefinitions: Array<t.Statement>;
} {
  const { rules } = ast.properties;
  const terminalRules = rules.filter(
    (rule): rule is SyntaxTerminalRuleNode => rule.type === SyntaxNodeType.TerminalRule,
  );
  const nonTerminalRules = rules.filter(
    (rule): rule is SyntaxNonTerminalRuleNode => rule.type === SyntaxNodeType.NonTerminalRule,
  );
  const publicRules = nonTerminalRules.filter((rule) =>
    isNodeTypeIdentifier(rule.properties.target),
  );
  const privateRules = nonTerminalRules.filter(
    (rule) => !isNodeTypeIdentifier(rule.properties.target),
  );

  const statements: Array<t.Statement> = [];

  // Add token types
  const tokenTypesStatements = formatTokenTypes(terminalRules, typeNamePrefix);
  statements.push(...tokenTypesStatements);

  // Add node types
  const nodeTypesStatements = formatNodeTypes(publicRules, typeNamePrefix);
  statements.push(...nodeTypesStatements);

  // Add node union type
  const nodeUnion = formatNodeUnion(publicRules, typeNamePrefix);
  if (nodeUnion) statements.push(nodeUnion);

  // Add root node type
  const rootNode = formatRootNode(nonTerminalRules, typeNamePrefix);
  if (rootNode) statements.push(rootNode);

  // Add node definitions
  const nodeDefinitions = formatNodeDefinitions(publicRules, typeNamePrefix);
  statements.push(...nodeDefinitions);

  // Add alias definitions
  const aliasDefinitions = formatAliasDefinitions(privateRules, typeNamePrefix);
  statements.push(...aliasDefinitions);

  return {
    tokenType: createTokenTypeUnionIdentifier(typeNamePrefix),
    nodeType: createNodeUnionIdentifier(typeNamePrefix),
    rootNodeType: createRootTypeIdentifier(typeNamePrefix),
    typeDefinitions: statements,
  };
}

function formatTokenTypes(
  rules: Array<SyntaxTerminalRuleNode>,
  typeNamePrefix: string,
): Array<t.Statement> {
  if (rules.length === 0) return [];

  const statements: Array<t.Statement> = [];

  // Generate union type combining all token types
  const unionMembers = rules.map((rule) =>
    t.tsTypeReference(
      createTokenTypeIdentifier(typeNamePrefix, rule.properties.target.properties.name),
    ),
  );
  statements.push(
    t.tsTypeAliasDeclaration(
      createTokenTypeUnionIdentifier(typeNamePrefix),
      null,
      t.tsUnionType(unionMembers),
    ),
  );

  // Generate individual type aliases for each token
  for (const rule of rules) {
    const tokenName = rule.properties.target.properties.name;
    statements.push(
      t.tsTypeAliasDeclaration(
        createTokenTypeIdentifier(typeNamePrefix, tokenName),
        null,
        t.tsLiteralType(t.stringLiteral(tokenName)),
      ),
    );
  }

  return statements;
}

function formatNodeTypes(
  rules: Array<SyntaxNonTerminalRuleNode>,
  typeNamePrefix: string,
): Array<t.Statement> {
  if (rules.length === 0) return [];

  const statements: Array<t.Statement> = [];

  // Generate union type combining all node types
  const unionMembers = rules.map((rule) =>
    t.tsTypeReference(
      createNodeTypeIdentifier(typeNamePrefix, rule.properties.target.properties.name),
    ),
  );
  statements.push(
    t.tsTypeAliasDeclaration(
      createNodeTypeUnionIdentifier(typeNamePrefix),
      null,
      t.tsUnionType(unionMembers),
    ),
  );

  // Generate individual type aliases for each node
  for (const rule of rules) {
    const nodeName = rule.properties.target.properties.name;
    statements.push(
      t.tsTypeAliasDeclaration(
        createNodeTypeIdentifier(typeNamePrefix, nodeName),
        null,
        t.tsLiteralType(t.stringLiteral(nodeName)),
      ),
    );
  }

  return statements;
}

function formatNodeUnion(
  rules: Array<SyntaxNonTerminalRuleNode>,
  typeNamePrefix: string,
): t.Statement | null {
  if (rules.length === 0) return null;

  const members = rules.map((rule) =>
    t.tsTypeReference(
      createRuleNodeIdentifier(typeNamePrefix, rule.properties.target.properties.name),
    ),
  );

  return t.tsTypeAliasDeclaration(
    createNodeUnionIdentifier(typeNamePrefix),
    null,
    t.tsUnionType(members),
  );
}

function formatRootNode(
  rules: Array<SyntaxNonTerminalRuleNode>,
  typeNamePrefix: string,
): t.Statement | null {
  const rootRule = rules.find((rule) => isNodeTypeIdentifier(rule.properties.target));
  if (!rootRule) return null;

  const rootRuleName = rootRule.properties.target.properties.name;
  return t.tsTypeAliasDeclaration(
    createRootTypeIdentifier(typeNamePrefix),
    null,
    t.tsTypeReference(createRuleNodeIdentifier(typeNamePrefix, rootRuleName)),
  );
}

function formatNodeDefinitions(
  rules: Array<SyntaxNonTerminalRuleNode>,
  typeNamePrefix: string,
): Array<t.Statement> {
  return rules.flatMap((rule) => {
    const ruleName = rule.properties.target.properties.name;
    if (rule.properties.value.type === SyntaxNodeType.Struct) {
      const properties = formatStructProperties(rule.properties.value, typeNamePrefix);
      return [
        t.tsTypeAliasDeclaration(
          createRuleNodeIdentifier(typeNamePrefix, ruleName),
          null,
          t.tsTypeReference(
            t.identifier(AST_NODE_TYPE),
            t.tsTypeParameterInstantiation([
              t.tsTypeReference(createNodeTypeIdentifier(typeNamePrefix, ruleName)),
              t.tsTypeReference(createRuleNodePropertiesIdentifier(typeNamePrefix, ruleName)),
            ]),
          ),
        ),
        t.tsInterfaceDeclaration(
          createRuleNodePropertiesIdentifier(typeNamePrefix, ruleName),
          null,
          null,
          t.tsInterfaceBody(properties),
        ),
      ];
    }
    const type = formatExpressionType(rule.properties.value, typeNamePrefix);
    return [
      t.tsTypeAliasDeclaration(createRuleNodeIdentifier(typeNamePrefix, ruleName), null, type),
    ];
  });
}

function formatAliasDefinitions(
  rules: Array<SyntaxNonTerminalRuleNode>,
  typeNamePrefix: string,
): Array<t.Statement> {
  return rules.map((rule) => {
    const ruleName = rule.properties.target.properties.name;
    const type = formatExpressionType(rule.properties.value, typeNamePrefix);
    return t.tsTypeAliasDeclaration(createPatternIdentifier(typeNamePrefix, ruleName), null, type);
  });
}

function formatExpressionType(expression: SyntaxExpressionNode, typeNamePrefix: string): t.TSType {
  switch (expression.type) {
    case SyntaxNodeType.Struct:
      return formatStructType(expression, typeNamePrefix);
    case SyntaxNodeType.Choice:
      return formatChoiceType(expression, typeNamePrefix);
    case SyntaxNodeType.Sequence:
      return formatSequenceType(expression, typeNamePrefix);
    case SyntaxNodeType.List:
      return formatListType(expression, typeNamePrefix);
    case SyntaxNodeType.Read:
      return formatReadType(expression, typeNamePrefix);
    case SyntaxNodeType.NonTerminalIdentifier:
      return formatNonTerminalIdentifierType(expression, typeNamePrefix);
    case SyntaxNodeType.TerminalIdentifier:
      return formatTerminalIdentifierType(expression, typeNamePrefix);
    case SyntaxNodeType.Empty:
      return formatEmptyType(expression);
    default:
      return unreachable(expression);
  }
}

function formatStructType(expression: SyntaxStructNode, typeNamePrefix: string): t.TSType {
  const properties = formatStructProperties(expression, typeNamePrefix);
  return t.tsTypeLiteral(properties);
}

function formatStructProperties(
  expression: SyntaxStructNode,
  typeNamePrefix: string,
): Array<t.TSTypeElement> {
  const { fields } = expression.properties;
  return fields
    .map((field) => {
      if (field.properties.name === null) return null;
      const key = field.properties.name;
      const valueType = formatExpressionType(field.properties.value, typeNamePrefix);
      return t.tsPropertySignature(t.identifier(key), t.tsTypeAnnotation(valueType));
    })
    .filter(isNonNull);
}

function formatChoiceType(expression: SyntaxChoiceNode, typeNamePrefix: string): t.TSType {
  const alternatives = expression.properties.alternatives.map((alternative) =>
    formatExpressionType(alternative, typeNamePrefix),
  );
  return t.tsUnionType(alternatives);
}

function formatSequenceType(expression: SyntaxSequenceNode, typeNamePrefix: string): t.TSType {
  const types = expression.properties.elements.map((element) =>
    formatExpressionType(element, typeNamePrefix),
  );
  return t.tsTupleType(types);
}

function formatListType(expression: SyntaxListNode, typeNamePrefix: string): t.TSType {
  const itemType = formatExpressionType(expression.properties.item, typeNamePrefix);
  return t.tsTypeReference(t.identifier('Array'), t.tsTypeParameterInstantiation([itemType]));
}

function formatReadType(_expression: SyntaxReadNode, _typeNamePrefix: string): t.TSType {
  return t.tsStringKeyword();
}

function formatNonTerminalIdentifierType(
  expression: SyntaxNonTerminalIdentifierNode,
  typeNamePrefix: string,
): t.TSType {
  if (isNodeTypeIdentifier(expression)) {
    return t.tsTypeReference(createRuleNodeIdentifier(typeNamePrefix, expression.properties.name));
  } else {
    return t.tsTypeReference(createPatternIdentifier(typeNamePrefix, expression.properties.name));
  }
}

function formatTerminalIdentifierType(
  expression: SyntaxTerminalIdentifierNode,
  typeNamePrefix: string,
): t.TSType {
  return t.tsTypeReference(
    t.identifier(TOKEN_TYPE),
    t.tsTypeParameterInstantiation([
      t.tsTypeReference(createTokenTypeIdentifier(typeNamePrefix, expression.properties.name)),
    ]),
  );
}

function formatEmptyType(_expression: SyntaxEmptyNode): t.TSType {
  return t.tsNullKeyword();
}

function createTokenTypeUnionIdentifier(typeNamePrefix: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}TokenType`);
}

function createTokenTypeIdentifier(typeNamePrefix: string, tokenName: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}TokenType_${tokenName}`);
}

function createNodeTypeUnionIdentifier(typeNamePrefix: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}NodeType`);
}

function createNodeTypeIdentifier(typeNamePrefix: string, nodeName: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}NodeType_${nodeName}`);
}

function createNodeUnionIdentifier(typeNamePrefix: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}Node`);
}

function createRootTypeIdentifier(typeNamePrefix: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}Root`);
}

function createRuleNodeIdentifier(typeNamePrefix: string, ruleName: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}${ruleName}Node`);
}

function createRuleNodePropertiesIdentifier(
  typeNamePrefix: string,
  ruleName: string,
): t.Identifier {
  return t.identifier(`${typeNamePrefix}${ruleName}NodeProperties`);
}

function createPatternIdentifier(typeNamePrefix: string, ruleName: string): t.Identifier {
  return t.identifier(`${typeNamePrefix}Pattern_${ruleName}`);
}

function isNamedModuleExportIdentifier(
  value: NodePath<t.Identifier>,
  moduleName: string,
  exportName: string,
): boolean {
  // Get the binding corresponding to the callee
  const binding = value.scope.getBinding(value.node.name);
  if (!binding) return false;
  // Determine whether the binding initializer denotes the exported item from the named module
  // Ensure the binding refers to an import specifier or import default specifier
  const bindingPath = binding.path;
  if (!bindingPath.isImportSpecifier() && !bindingPath.isImportDefaultSpecifier()) {
    return false;
  }
  // Get the import declaration
  const importDeclaration = bindingPath.parentPath;
  if (!importDeclaration.isImportDeclaration()) return false;
  // Ensure the import is from the correct module
  if (importDeclaration.node.source.value !== moduleName) return false;
  // Ensure the imported item has the correct export name
  if (bindingPath.isImportDefaultSpecifier()) return exportName === 'default';
  const importedItem = bindingPath.node.imported;
  if (t.isIdentifier(importedItem)) return importedItem.name === exportName;
  if (t.isStringLiteral(importedItem)) return importedItem.value === exportName;
  return false;
}

function parseStringLiteral(
  arg: t.ArgumentPlaceholder | t.SpreadElement | t.Expression,
): string | null {
  if (t.isStringLiteral(arg)) return arg.value;
  if (t.isTemplateLiteral(arg)) {
    const stringArgs = arg.expressions
      .map((expr) => (t.isExpression(expr) ? parseStringLiteral(expr) : null))
      .filter((value) => value !== null);
    if (stringArgs.length !== arg.expressions.length) return null;
    return arg.quasis
      .map((quasi, index, quasis) => {
        const templateString = quasi.value.cooked ?? quasi.value.raw;
        if (index === quasis.length - 1) return templateString;
        const stringArg = stringArgs[index];
        return `${templateString}${stringArg}`;
      })
      .join('');
  }
  return null;
}
